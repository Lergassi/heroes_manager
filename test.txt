let attackPower = new AttackPower(
    10, //Значения фиксированные и не меняются.
    20,
);

attackPower.generate(); //Случайное значение из диапазона.

let attackPowerCharacterAttribute = new CharacterAttribute(42);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);

attackPower = new AttackPowerIncreaseDecorator(
    attackPower,
    attackPowerCharacterAttribute,  //И не нужно делать никаких действий над диапазоном. Он уже задан. А усиления просто сдвигают значения вправо.
);

range(): {left: number, right: number} {
    return {
        left: this._left + this._apCharacterAttribute.value(),
        right: this._right + this._apCharacterAttribute.value(),
    };
}

generateAttackPower(): number {
    //let range = this.range();
    //return _.random(this._left + this._apCharacterAttribute.value(), this._right + this._apCharacterAttribute.value());

    return this._attackPower.generateAttackPower() + this._apCharacterAttribute.value();
}

attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
//...

damage.attack(target) {
    let damage = _.range(this.left, this._right);

    target.attack(damage);
}

hero1.damage.attack(hero2.attackController);
//или
let damage = damage.generateAttack();
hero1.damageController.attack(damage);

//////////////////////////////////////////

/*
    Герой не может атаковать и совершать другие действия (двигаться) если мертвый.
    Герой не может атаковать и совершать другие действия (двигаться) если на нем какие-либо эффекты: стан.

    Цель не может получить урон если мертва.
    Цель не может получить урон на ней какие-либо эффекты: неуязвимость.

    Пока у героя только атака пусть это будет через дополнительный класс с методом assertCanAction() например.

    Кстате это разные действия. Получить урон - это просто операция с числами, атака - физическая.
    Герой не может просто так сменить состояние. Его нужно именно воскресить.
*/
hero.attack(target);

/////

//actionController.action('атака', hero);
hero.attack(target);
attack(target) {
    //this._actionController.assertAction('attack');
}

контроллер.действие(действие, () => {
    hero.attack(target);    //хм...
})

actionController = new ActionController();
hero //это контейнер. actionController внутри. Сам ни от чего не зависит. А нет - зависит. Тоже декоратор?

health = new Health();
health = new ActionController(health);  //и чё?
health = new Armor(health);
health = new MagicArmor(health);

//Надо сделать так, чтобы состояние нельзя было изменить из любой точки программы. Если объект ничего

health = new Health(actionController);
Health {
    Health(actionController) {
        this._actionController.assign(() => {
            return this._isDead;
        });
    }

    kill() {
        this._actionController.setState(Dead);
    }

    resurrect() {
        this._actionController.setState(Life);
    }
}

stun() {
    this._actionController.setState(Stun);
}

hero.block();
hero.unblock();
hero.assertAction('attack');

hero.addState('dead');  //Все остальные эффекты удаляются.
hero.addState('stun');  //Если есть эффект dead другие действия не возможны.

states = [];
if (state === dead) {
    states.clear();
    states.add(state);
}

// Вариант работы с сумками.

itemStorages.create(...);
itemStorages.create(...);
itemStorages.create(...);
itemStorages.add(...);  //Если сумка в банке.
create(factory) {
    let itemStorage = this._itemStorageCollection.create(factory.create);   //Проверка на максимальное число сумок.
    this._itemStorageGroup.add(itemStorage);    //Можно добавлять и удалять любые сумки.
    //Таким образом объект-контейнер содержит интерфейсы и сам обладает необходимым интерфейсом типа create/delete. И при этом наружу показывается не реализация, а интерфейс и поэтому this._itemStorageGroup возвращает интерфейс addItem(), а this._itemStorageCollection снаружи нет вообще. Т.е контейнер по сути есть............... декоратор или заместитель???
}
delete(itemStorage) {
    this._itemStorageCollection.delete(itemStorage);
    this._itemStorageGroup.delete(itemStorage);
}

itemStorages.delete(...);
itemStorages.delete(...);
itemStorages.delete(...);

//itemStorages.ItemStorageCollectionInterface;   //Для манипуляции с коллекцией. --- Не нужно, для этого есть сам контейнер реализующий интерфейс контейнера, и далее в проект передается не контейнер, а интерфейс. В том числе не нужно передавать будет по всему проекту GameObject и разбираться что это такое за объект.
itemStorages.AddItemInterface;                 //Для добавления предметов и только.

//----------------------------------------------
let itemStorageSlot = new ItemStorageSlot();
itemStorageSlot.createItem('wood', 12);
itemStorageSlot.replace(...);
itemStorageSlot.destroyItem();

//Предмет храниться внутри itemStack. ItemStack внутри слота сумки или слота экипировки. За логику добавление предмета в стек, удаления отвечает сам ItemStack. Значит к нему должен быть доступ из какого места программы. Дублировать интерфейс точно не надо.
//Вопрос: а как сортировать предметы в сумке? Слоты это же массив...

let slots = [
    new Slot(),
    new Slot(),
    //...
    new Slot(),
];

let itemStorage = new ItemStorage(slots);

//itemStorage.slots[3].separate(12);     //return new ItemStack(item, 12):
itemStorage.slots.get(3).separate(12);     //return new ItemStack(item, 12):    .get(3) выбросит исключение если слота нет.
//Можно управлять слотами по отдельности - они доступны снаружи.


