//****************************************************************
    атрибуты и "ооп"
//****************************************************************
ловкость
- Базовое значение. Можно увеличить, но нельзя уменьшить. Значение героя без экипировки.
- Усиления от экипировки.
- Усиления от баффов.
- Усиления от зелий.
- Усиления от скиллов.
- Услиения от навыков (+4 ловкости)

Вопрос: а зачем вообще нужна ловкость???
От ловкости зависит:
- Урон у ловких героев.
- Возможность носить экипировку с требование на ловкость.
- Возможность использования навыков. (дивинити. Инта точно.)
- Допустим еще ряд параметров у ловких героев.

Урон = базовый урон + ловкость * 10 //где ловкость итоговая ловкость героя. Базовый урон храниться в базовом уроне. Где храниться усиление?
атака.атаковать(цель)
	цель.нанестиУрон(_урон())

атака._урон()
	случайноеЧисло(_мин, _макс)		//_мин, _макс зависят от силы атаки и ловкости

если герой.ловкость < 10
	герой не может носить данный шлем
	вернуть ложь
иначе
	экипировать
Также отображается в предмете если экипировка не доступна.

если герой.ловкость < 4
	нельзя использовать удар в спину
инчае
	использовать удар в спину
Также отображается в скилле если использование не доступно.

экипировать (предмет)
	если предмет.имеетОграничениеПоЛовкости
		если _герой.ловкость меньше шлем.ограничениеПоЛовкости	//Два метода на одну логику? Без учета множества атрибутов (пусть будет одна логика) допустим такой логики будет много. Проверка на класс, материал брони, можно ли удалить героя или создать, можно ли создать предмет, можно атаковать - каждый раз придется писать два метода?
			ошибка(герой не может экипировать предмет)

	_предмет = предмет

если можно создать предмет
	создать предмет
если можно разделить предмет
	разделить предмет
если ловкость больше x1
	сделать действие 1
	сделать действие 2
	сделать действие ...
	сделать действие x2
действие.выполнить()
	если ловкость меньше нужной
		ошибка(нельзя выполнить действие)
		вернуть -1
экипироватьПредмет(предмет)					//для экипировки. Логика у слота.
	если ловкость меньше нужной
		ошибка(нельзя выполнить действие)
		вернуть -1
можноЭкипироватьПредмет(предмет)			//для интерфейса. Логика у предмета в инвентаре игрока, на аукционе, в магазине, в крафте. Т.е. логика не зависит от игрока, а должна иметь интерфейс взамодействия с любым объектом в игре. Значит: предмет.можноЭкипировать(ловкость)
	если ловкость меньше нужной
		ошибка(нельзя выполнить действие)
		вернуть -1

предмет.можноЭкипировать(ловкость: число | Ловкость | Атрибут)			//и не от большого объекта. Так меньше связность или это называется.
	вернуть ловкость >= _нужноЛовкости
	или
	атрибут.есть(_требованиеЛовкости)
	атрибут.equal(_требованиеЛовкости) //меньше -1 равно 0 больше 1
	атрибут.проверка(_нужноЛовкости)

предмет.можноЭкипировать(ловкость: число)	//метод можноЭкипировать означает что ему нужна не ловкость, а вообще всё. Сила, ловкость, интеллект, уровень героя или игрока, удача, класс героя, роль героя, доступный материал героя, слот экипировки.
ловкость.проверка(предмет)
	вернуть предмет.можноЭкипировать(_значение)

предмет.можноЭкипировать(...)
																/*
																	Все эти данные храняться сейчас в разных классах. И имеют разный интерфейс. Может проверка на возможность экипировать это другая задача и требует отдельного решения?
																	И вообще - зачем просто так хранить число? Оно должно быть используемое в логике.

																	Шанс крита. В простом варианте это метод принимающий некоторое значение (критический удар) и возвращающее шанс в пределах 0-100 (или более). Или имеющее максиальное значение, например 50%. Или ограничение может быть в другом месте.
																	критическийУдар.расчитатьШанс(шанс)
																		вернуть шанс.расчитатьШанс(_значение)
																	//или
																	критическийУдар.расчитатьШанс(шанс)
																		шанс.расчитатьШанс(_значение)	//И в этот момент чтото происходит и метод должен называться не расчитатьШанс, а как то иначе. Усилить?
																	//или с другим названием
																	критическийУдар.усилитьУрон(урон)	//усилитьУрон - это интерфейс. Если некоторый объект позволяет это сделать у него должен быть реализован этот метод.
																		если шанс крита сработал
																			вернуть урон * множитель
																		иначе
																			вернуть урон
																	/*
																		интерфейс у ловкости
																		У каждого героя свой набор атрибутов: сила у воинов, инта у магов, сила+инта у паладина.
																	*/
																	ловкость.усилитьУрон(урон)	//Т.е. сама ловкость и отвечает за усиление той лоники какой интерфейс реализует.
																		вернуть урон + _значение * коэффициент
																		//или
																		урон.усилить(_начение * коэффициент)
																		//если это бафф будет еще такая логика гдето:
																		урон.уменьшить(_начение * коэффициент)	//ИДЕЯ: Т.е. получается даже урон можно/нужно усиливать не числом, а прямо в объекте. Урон также сам разбеется можно его усилить или нет. Например герой в стане или мертвый или достигнут кап урона. У усилить можно вообще всё что угодно с любым интерфейсом .усилить(значение).
																	//...
																	атака.атака(цель)
																		...
																		//урон = обычный или усиленный от крита
																		урон = _урон + _урон * множительУронаОтКрита	/*
																															множительУронаОтКрита задаётся на всю игру или на героя (класс атаки). Например х2.

																														*/
																		если шанс крита сработал
																			урон = _урон + _урон * множительУронаОтКрита
																		иначе	//обычный урон
																			урон = _урон
																		//или

																		...
																*/
	если цель.естьСила(_нужноСилы)								//сила
	если цель.естьЛовкость(_нужноЛовкости)						//ловкость
	если цель.естьУдача(_нужноУдачи)							//удача
	если цель.естьУровень(_нужноУровня)							//уровень героя
	если цель.естьКлассГероя(_нужноКлассГероя)					//класс героя
	если цель.доступнаБроня(_типБрони)							//доступная броня героя

    //правило = Правило()
    правилоПоСиле = ПравилоПоСиле(4)
    //или
    правилоПоСиле = ПравилоПоСиле(предмет.требованияПоСиле)
    правилоПоСиле = предмет.создатьПравилоПоСиле()          //Т.е. отдельная логика с числом в конструкторе. Число вообще никак не зависит от предмета. Его можно удобно использовать, а главное тестировать. Также: число сейчас храниться в предмете, потом может в другом месте. И правило не привязано к предмету.
    правилоПоСиле.проверить(геро._сила) //нужно гдето получить числовое значение без геттера.

    предмет.можноЭкипировать(правилоПоСиле)
    предмет.можноЭкипировать(правилоПоЛовкости)
    предмет.можноЭкипировать(правилоПоУровню)
    предмет.можноЭкипировать(правилоПоБроне)
    ...
    //или
    правилоПоСиле.проверить(герой._сила)
    герой.проверить(правилоПоСиле)  //Нужно правило передать в нужный объект.

    герой.сила.проверить(правилоПоСиле)             //число
    герой.ловкость.проверить(правилоПоЛовкости)     //число
    герой.уровень.проверить(правилоПоУровню)        //число
    герой.класс.проверить(правилоПоКлассу)          //класс или число(id)
    герой.доступнаяБроня.проверить(правилоПоБроне)  //массив объектов или массив чисел

    /*

    */

Правило
    Правило(число)
        _число = число
    проверить(число)
        вернуть _число = число

ПравилоПоСиле
    ПравилоПоСиле(число)
        _число = число
    проверить(число)
        вернуть число >= _число

ПравилоПоУровню как число
ПравилоПоКлассу
    ПравилоПоКлассу(класс)
        _класс = класс
    проверить(класс)
        вернуть _класс === класс

ПравилоПоТипуБрони
    ПравилоПоТипуБрони(типБрони)
    проверить(типБрони)
        вернуть _типБрони === типБрони


слот.экипировать(предмет, НаборПравил([
    [правилоПоСиле, сила],
    [правилоПоЛовкости, ловкость],
    [правилоПоУровню, уровень],
    [правилоПоКлассу, класс],
    [правилоПоТипБрони, доступныеТипыБрони],
]))
//

ловкость.проверить(цель: Проверка) //где проверка(значение: число)
	вернуть цель.проверка(_значение)

слот.экипировать(предмет)
	если предмет.можноЭкипировать(_ловкость)

Получается это два метода которые работают только вместе и всегда вызываются в паре. И так на каждую логику.
1. Повторение кода.
2. Я сам забуду как этим пользоваться и другие разработчики тоже. И так во всей программе.

если герой.ловкость < 10
	герой не может носить данный шлем
	вернуть ложь
иначе
	экипировать

ловкость.добавитьЗависимость(силаАтаки)

Проверка на возможность экипировать предмет.
- Ловкость.
- Класс.
- Материал брони.

Значение требования храниться в предмете.
Ловкость в ловкости.
Класс в классе.
Материал брони героя в классе или у героя.

Все эти проверки нужно делать с разными объектами.

предмет.можноЭкипировать()

//****************************************************************
    Логика и ui.
//****************************************************************
/*
    Логика и интерфейс должны быть разделены в любом случае.

    Для теста: кошелек, сумка со слотами (текущая версия), герои (слоты, атрибуты, хп).

    Вариант 1:
    Допустим есть кошелек с методами добавить()/удалить()/оплатить(покупка)/передать(цель: ИнтерфейсКошелька) и тд.
    Для вывода нужно только одно значение изнутри класса, которое обновляется при изменении. Значение из вне не доступно (private).
    Даже если не учитывать react, а свою систему, canvas и тд то логика примерно одна: рендер происходит при изменении значения. Винда вроде также работает: InvalidateRect если правильно помню.

    Значит внутри класса в месте _value += value должно чтото происходить.

    кошелекЮИ = КошелекЮИ()
    кошелек = Кошелек(данные, кошелекЮИ?)

    добавить(значение)
        _значение += значение
        _юи?.обновить({
            значение: _значение,
        })

    <КошелекЮИ
        this._container.get(кошелекЮИ)
    />
*/

кошелек = Кошелек(0)    //может быть не только у игрока.
кошелек.добавить(42)

//Шаблон 1
<span>Золото: {значение}</span>
кошелек.рендер(рендер, шаблон)
    рендер
    рендер.рендер(шаблон, _значение)

слот = Слот()
у слота есть задний фон и всё.
слот.рендер() рендер только фона и всё.
слот.установитьИзображение(изображение)
слот.убратьИзображение(изображение)

слот = СлотДляСтека()
СлотДляСтека
    СлотДляСтека()
        _слот = Слот()
        _стек = пусто
    установить(предмет, кол-во)
    удалить()
    обновитьКолВо(кол-во)

Доступ к ui через несколько классов мозможно не правильный. Например если в интерфейсе будет 3 поля, 5 кнопок, 2 текста и тд, то как их привязать к объекту?

React.
Получается итоговый компонент не виден снаружи вообще.

//****************************************************************
    Логика и ui. в2.
//****************************************************************
/*
    В игре должен быть только 1 интерфейс для доступа к объектам. Есть множество сумок, сундуков, трупов (тоже сумка), карманная кража (скайрим) и тд. Всегда при взаимодействии с таким объектом открывается окно интерфейса и приисходит взаимодействие. Значит они должны быть совместимы. И объект должен реализовать механизм доступа.

    Интерфейс может работать в разы проще и вообще не оперировать объектами.
    Для слота сумки для игрока нужны след действия:
    1. Установить иконку.
    2. Число предметов в стеке.
    3. Привязать логику: кнопка удаления стека, разделение стека, пермещение стека (в слот, экипировка, почта - в будущем одна логика слота).
    При очищении слота всё удалить и оставить иконку фона слота.
    И эта логика созданная один раз больше никогда не поменяется. А логика работы сумок и всего остального будет меняться. Например у слота экипировки сейчас 3 декоратора. 1 скоро уберется, возможно вообще все, измениться класс и интерфейс, а в будущем слоты станут одним классом. А логика для пользователя остается неизменной: слот - иконка и число - 3 действия со слотом.
*/

слот = СлотЮИ(задний фон)
слот.обновить(предмет, кол-во)  //Нужен именно предмет, так как там есть доп информация кроме иконки: название, редкость, описание и тд.
слот.очистить() //доступно игроку.

слот.прикрепить(слотЮИ)
или
слот.прикрепить({
    цель: this,                         //А зачем цель?
    обновитьЗначени: (значение) => {    //Такого метода не должно быть в открытых методах.
        this.setState({
            значение: значение,
        });
    },
    обновитьЗначени: this._обновитьЗначение,
})

_обновитьЗначение(значение) {
    this.setState({
        значение: значение,
    });
}
//
attach({
    событие1: функция,
    событие2: функция,
    ...
    событие_: функция,
})

attach(
    контроллерСобытий
)

//Итоги
Пусть логика не зависит напрямую от классов ui. Будут универсальные методы отслеживания как события. Т.е. в сумку, героя и тд передается не интерфейс, а функции/классы для отслеживания события updateSlotHandler, updateAgilityHandler и тд.

//****************************************************************
    Заметки.
//****************************************************************
А почему бы не сделать у HealthComponent много методов и передавать его другим компонентам? Т.е. наносить урон не напрямую, а через DamageController/AttackController, ххил через HealController и тд. Компонент 1, но работают с ним другие. Прямого доступа практически нету.

--- Другое, не к идеи выше...: Также с сумкой - один или несколько универсальных объектов на основе которых собирается сумка со слотами для игрока, без слотов для техничесих нужд, скрытая сумка, сундук, труп, крафт (резерв предметов), лутбоск и тд. И где нужно передавать интерфейс: добавление/удаление предметов, слот (один) или массив.
EquipSlot - тоже может работать как сумка. Один интерфейс для экипировки, другой для сбора атрибутов. Без декораторов.

"ООП"
- Идея. Исходящие данные должны быть скрыты, входящие иметь методы. Например attack(): number у AttackController - не верно, takeDamage(damage: number) - верно. Суть. Если герой не может атаковать (мертвый, стан) - то он не может атаковать, а это просто генерация одного числа. Решено отказаться от исключений и получается что метод поменять сложно. Он должен вернуть 0 и напечатать сообщение.......


// dj
Если внутри конструктора класса создается один объект через new это работает до тех пор пока у него нет параметров. Проблемы могут появиться когда нужно указать хотя бы 2-3 аргумента и таких объектов будет например 3 - 3*3 = примерно 10 аргументов + еще аргументы самного объекта = 15. И как разобраться в этом всем будет дальше?

//****************************************************************

//****************************************************************
    бд.
//****************************************************************

бд = БазаДанных()   //Только предметы. А категории?

//прямые методы или с репозиториями, не суть
бд.найтиПредметПоКатегории(ресурсы)
бд.найтиПредметПоКатегории(одноручныеМечи)
бд.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

//Вариант с интерфейсом. И получается что не у бд куча методов, а у отдельного объекта, который есть у бд.
бд.поиск.найтиПредметПоКатегории(ресурсы)
бд.поиск.найтиПредметПоКатегории(одноручныеМечи)
бд.поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

создатьВрага(поиск: ИнтерфейсПоискаПредметов) {  //Таким образом когда будет создана нормальная бд не придется везде заменять объект ItemDatabase. А сам интерфейс будет браться из бд: бд.поиск - можно также? todo: Надо попробовать. Сделать так сумки и слоты. И героев.
    лут += поиск.найтиПредметПоКатегории(ресурсы)
    лут += поиск.найтиПредметПоКатегории(одноручныеМечи)
    лут += поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)
}

/*
    Факт: подобные данные не меняются не то что во время создания, а вообще в играх вроде. Только при разработке. Игру даже при разработке нужно перезагрузить.
    Получается что данные можно дублировать в сущности и бд и связать к данным объект?
*/
дерево = Предмет(дерево, ресурсы)
двуручныйМеч = Предмет(двуручныйМеч, одноручныеМечи, {двуручноеОружие: истина})
латныйШлем = Предмет(латныйШлем, шлемы, {материал: латы})

//Как это может быть
БазаДанных {
    БазаДанных() {
        _предметы = {}
        _поиск = Поиск()
    }

    добавить(id, предмет) {
            _предметы[id] = предмет
            _поиск.индекс(...) //А как если у предмета всё скрыто? Видимо не тут. Вроде как на каждый объект планируется фабрика (сущности, компоненты) - можно там всё делать.
        }

    //удалить(id | предмет) {
    //
    //}

    //метод
    найтиПредметПоКатегории(категория) {

    }
    //интерфейс
    поиск() {
        вернуть _поиск
    }
}

//****************************************************************
    Герои и интерфейс.
//****************************************************************
Герой {

}

герой.слоты.голова.экипировать(шлем)
герой.слоты.плечи.экипировать(наплечники)
герой.слоты.праваяРука.экипировать(двуручныйМеч)
герой.слоты.леваяРука.экипировать(щит)  //Будет ошибка.

герой.атрибуты.сила
герой.атрибуты.силаАтаки

//Использование героев.
location.addHero(hero: ...) {}
простоГруппа.addHero(hero: ...) {}
подземельей.addHero(hero: ...) {}
рейд.addHero(hero: ...) {}
бг.addHero(hero: ...) {}
//и тд...
/*
    Допустим всем внутри нужны разные данные в кол-ве 2-3 интерфейсов.
    LevelInterface
    HeroClassInterface  //Максимум 1 танк на пати.
    КакойТоИнтерфейс
*/
//сейчас:
локация.добавитьГероя(герой: GameObject) {
    герой.получитьКомпонент(уровень)    //То что внутри нужен интерфейс уровня никто из разработчиков не знает. При условии что GameObject может содержать (или нет) всё что угодно.
}

//локация.добавитьГероя(герой: ...) {
локация.добавитьГероя(уровень: Уровень) {
    если уровень.значение < 42
        ошибка: Герой слишком маленький для данной локации.

    //герои.добавить(герой)   //А героя нету.
}

//И это должен быть именной герой. А в чем проблема сделать класс Герой и выкинуть GameObject? Внутри героя как в react соберу нужного героя.
локация.добавитьГероя(герой: УровеньИнтерфейс) {

}

Уровень {
    значение
    опыт
    добавитьОпыт(значение)
}

УровеньУГерояИнтерфейс {
    уровень: Уровень
}

//герой реализовать УровеньИнтерфейс {
//герой {
герой реализовать УровеньУГерояИнтерфейс, СлотыУГероя, КлассУГероя ... и тд - очень много интерфейсов которые, можно получить через геттер {
    уровень: Уровень
    слоты
    атака
    здоровье
    магия
    ...
}

ГеройКакReact {
    уровень
    сила
    ловкость
    интеллект
    очкиЗдоровья    //Какой смысл от подобного компонента на чтение? Нанести урон - отдельный компонент.
    очкиМагии

    ГеройКакReact(
        уровеньЧисло,
        сла,
        лов,
        инт,
    ) {
        уровень = Уровень(уровеньЧисло)
        сила = сла
        лов = лов
        //Полоучается очень большой конструктор. В фабрике и передавать внутрь? Все компоненты будут доступны из вне там где нужно.
    }
}

//****************************************************************
    Один большой объект или много небольших + private/public
    private/public
    Пока итог такой:
        В сущностях все данные открыты через геттеры.
        По возможности использовать как со слотами - создавать на их основе объекты. Так удобно - можно заменить любую логику и не зависить от большого объекта.
        Там где можно использовать методы, а не данные.
            Например создать генератор золота можно через метод фабрику в одну строку вместо получения массива и передачи его генератору.
            Или данные у рецепта: не геттер а метод примерно такой создатьПредмет(списокСтеков | сумка) - и рецепт проверит можно ли создать рецепт и вернет нужно кол-во стеков или сразу поместит их в сумку.
        Возможно сущности Item тоже не будет. Данные и логика будут передаваться в объект отдельно и никак не будут зависеть от Item.
//****************************************************************************************


Класс {
    private:
        /*
            И... какой смысл от этого если всё закрыто? Данные нужны в случайном месте.
            А зачем вообще нужен HeroClass? Как его использовать кроме данных?
            Допустим есть роль. Самое очевидное использование: если танк то {} иначе {}. Поведение героя будет зависить не от роли, а той логики которая будет передана ему.
                воин = Воин(
                    сила: 20,
                    защита: 30%,
                    стратегияНабораАгресии,
                )
            стратегияНабораАгресии у танка одна, у дд другая, у саппорта еще другая. А также в каждый класс можно передать уникальную стратегию.
            EquipSlot уже практически не используется в методах, а только при создании настоящего слота.
        */
        название
        главныеАтрибуты
        материалыБрони
        доступноеОружие
        роль
        опции = {
            доступныЩиты: 1
        }
        //И где в случайном месте правила для правой и левой рук.
    public:
        ...
}

воини = Класс(воин, [сила], [латы], [одноручноеОружие], танк)
маг = Класс(маг, [инт], [ткань], [посохи, ванды], дд)
...

//****************************************************************
    Контейнеры с логикой интерфейсов.
//****************************************************************

ItemStorageContainer {
    ItemStorageContainerInterface();        //Добавление, удаление предметов. А внутри оно храниться по своей логике. Никаких слотов.
    ItemStorageSlotInterface();             //Привязка к внутренней структуре.
}

itemStorage.ItemStorageContainerInterface.addItem(wood, 123);   //Просто в сумку с объединением.
itemStorage.ItemStorageContainerInterface.removeItem(wood, 123);
itemStorage.ItemStorageContainerInterface.hasItem(wood);

ItemStorageContainer(размер) {
    _контейнер = Контейнер(размер)      //Это без слотов. Просто контейнер.
    _слоты = Слот()[размер]             //Это сами слоты. Не имеют отношения к сумкам.
}

//дерево 2000, стек = 20 = 50 стеков, размер контейнера = 20. 1000 не добавяться.
добавитьПредмет(предмет, кол_во) {
    //вернуть _добавитьПредметыСОбъединение(предмет, кол_во)  //остаток
    //А как получить доступ к...
    //_контейнер.добавитьПредмет(предмет, кол_во) //Там внутри тоже есть стеки.
    стеки = _контейнер.добавитьПредмет(предмет, кол_во) //Там внутри тоже есть стеки.
    //!!! А что если слоты передать через зависимость. Для простого контейнера это просто массив. Для игрока это слоты сумки... хм... Что мне мешает управлять слотами отдельно? Я же могу очистить слот в обход сумки? слот.очистить()

    //_слоты.добавить
}
удалитьПредмет(предмет, кол_во) {
    _контейнер.удалитьПредмет(предмет, кол_во)
}

itemStorage.ItemStorageSlotInterface.slot(12).clear();
clear(index) {
    this.ItemStorageContainerInterface.remove(this._slots[index].item, this._slots[index].count);
    this._slots[index].clear();
}

HeroContainer {
    Слоты
    Предметы    //Отдельно от слотов.
    Атрибуты
}

//****************************************************************
    Контейнеры с инъекцией слотов.
//****************************************************************
/*
    Заметка про стеки. Стек может быть с maxSize для сумок или без ограничений например для лута. Например в луте может быть 5 MagicResource или 10 мечей в стеке - нет, плохая идея.
*/
/*
    Все сценарии работы с сумками и предметами в сумках.
        - Добавление/удаление предметов. С объединением стеков.
        - Разделение стека, объединение в стек.
        - Сортировка.
        - Перемещение из одного слота в другой.
*/

КонтейнерБезСлотов {
    _слоты: Стек[]
    КонтейнерБезСлотов(размер) {
        _слоты = Стек[размер]
    }
    добавитьПредмет(предмет, кол_во) {
        алгоритм: добавить предметы. Не полные стеки дополняются, создаются новые стеки. Если предметы останутся возврат остатка. Просто заполняется обычный массив. Вне класса ничего не доступно.

    }
    //Если просто массив, то удаление предмета будет так:
    удалитьПредмет(предмет, кол_во) {
        for индекс в _слоты
            если остаток <= 0
                break

            если _слоты[индекс] не пусто
                остаток = _слоты[индекс].удалить(предмет, кол_во) //стек сам разберется. Если там есть предмет удаление, иначе ничего не делать и возврат остаток = кол_во
                //И самое главное: как стек удалит себя если стек снизиться до нуля?
            //А если без проверки массива на существование стека и с слотом.
            _слоты[индекс].удалить(предмет, кол_во) //Та же логика без условий. И внутри если стек больше не нужен, то слот удалит его. При это логика тут вообще не затрониться и не сломается...
            /*
                Идея. Стек можно удалять или создавать. Во-первых зачем его создавать/удалять если можно просто указывать item/count в слоте? И добавлять предметы не стеку, а слоту.
                Во-вторых. Если стек будет. То стек предполагается создание и удаление. Сам себя стек не может удалить, аэто значит что нужна обертка для стек. Если это будет сумка:
                    _стеки[индекс].удалить(предмет, кол_во)
                    если _стеки[индекс].пустой()    //Тут получается что стек становится в не верном состоянии, что не должно допускаться.
                        _стеки[индекс] = пусто  //сам стек снаружи должен быть не доступен иначе вся логика сломается. С героями по другому - если герой снаружи чтото делает у него меняется статус.
                Если стек снизиться до нуля, а выше по коду не будет логики удаления стека из места - останется пустой стек. Без стеков?
                Получается чтобы управлять стеком нужен другой класс? СтекКонтроллер
            */
    }
}

КонтейнерСоСлотами {
    _слоты: СлотИнтерфейс[]
    КонтейнерСоСлотами(слоты: СлотИнтерфейс[]) {    //Только может не СлотИнтерфейс, а СтекИнтерфейс? Слоты нужны только для игрока.
        _слоты = слоты
    }
    добавитьПредмет(предмет, кол_во) {
        тот же алгоритм, только слоты теперь объект
        _слот[12].добавить(предмет, кол_во) //если внутри правильный объект - добавляется, иначе создается стек. возврат остаток
        for слот в _слоты
            если кол_во <= 0
                break

            кол_во -= слот.добавитьПредмет(предмет, кол_во) //И получается: сумка ничего не знает о стеках и как с ними работать - это работа за слотом. И если мне нужно очистить определенный слот для этого есть отдельный массив слотов. А что если слоты тоже выделить в отдельный класс? Если мне нужно очитить слот просто нужно ввести index вместо сумкаИД слотИД.
    }
}

//Если убрать стеки.
СлотСумки {
    СлотСумки() {
        _предмет = пусто
        _кол-во = 0
    }
    добавитьПредмет(предмет, кол-во) {
        если пусто
            _предмет = предмет
            _кол-во = кол-во <= предмет.размерСтека ? кол-во : предмет.размерСтека
            кол-во -= _кол-во
        иначе
            новыхПредметов = кол-во <= тут.недостаток() ? кол-во : тут.недостаток()
            _кол-во += новыхПредметов
            кол-во -= новыхПредметов

        возврат кол-во
    }
    удалитьПредмет(предмет, кол-во) {}
    естьлиПредмет(предмет, кол-во) {}
}

/*
    Если со стеком, то сначала нужно проверить создан ли он и потом его использовать.
    если стол.пустой
        слот.создатьСтек
    иначе
        слот.стек.добавитьПредмет(предмет, кол-во)
*/

СлотЭкипировки {
    экипировкать(предмет) {}
    экипировкать(предмет, кол-во) {}    //Если это слот для используемых предметов.
    экипировкать(стек) {}
}

СлотПредмета {
    _стек

    get стек???

    установить() {}
    создать() {}
    очистить() {}

    добавить() {}   //Это к стеку.
    удалить(кол_во) {}   //Это к стеку.
}

//декоратор
/*
    СтекКонтроллер, СтекВраппер реализовать СтекИнтерфейс {
        _стек
        СтекКонтроллер(стек) {
        }
        удалитьПредмет(предмет, кол_во) {
            остаток = _стек.удалитьПредмет(предмет, кол_во)
            если остаток и _стек.содержит(предмет, 1)
                _стек = пусто
                остаток--
            //или если можно снизить до нуля. Проще тогда до нуля снижать стек.
            если _стек.пустой
                _стек = пусто
        }
    }
*/

//ВОПРОС: Так ли нужен стек для перемещения и прочих манипуляций? Например есть 2 стека дерева - это просто дерево. Если без стеков - то как делать сортировку? Что перемещать? А что если к сумке сделать еще 1 сумку дубликать и при сортировки просто добавлять тупа по порядку предметы а потом менять сумки?
СтекКонтроллер: СтекИнтерфейс?
    _стек
    СтекКонтроллер
        _стек = пусто
    добавить(предмет, кол-во)   //кол-во может быть больше стека 1000000000
        остаток = 0
        если !_стек
            _стек = Стек(предмет)
            // или если очень надо чтобы стек не был с 0 предметов
            _стек = Стек(предмет, 1)
            --кол-во
        остаток = _стек.добавить(предмет, кол-во)
        вернуть остаток
    уничтожить()    //ссылки на стека нет можно безопасно удалить объект
        _стек = пусто
    очистить(цель)
    разделить(цель: СтекКонтроллер, предмет, кол-во)
        если !_стек
            вернуть пусто или ошибка

        новыеСтек = _стек.разделить(предмет, кол-во) //новый стек может быть разметор n - 1. За правильное указание нужных значений отвечает другая часть программы и интерфейс. Никаких ошибок тут не будет - физически нельзя указать размер нового стека равное размеру исходного стека. И создается именно стек а не слот - поэтому стеки нужны. Например при резерве ресурсов для крафта их можно помещать в стек без ограничения на максимальный размер (отдельный класс) и помещать в сумку без слотов.
        //если _стек.пустой
        //    _стек = пусто

        //вернуть новыйСтек
        цель.разместить(новыйСтек)

//Сортировка и перемещение со слотами
слот.поменять(слот)
поменять(слот) {    //С экипировкой работать не будет.
    т_стек = слот._стек
    слот_стек = _стек
    _стек = т_стек
}

МестоПодСтекИнтерфейс
    разместить(стек)
    содержит(стек)

//**** Как перенести стек, чтобы он не потерялся.
слот.переместить(цель: МестоПодСтекИнтерфейс) {
    цель.разместить(_стек)  //Можно сделать так, что за управление стеком отвечает исходное место. Цель может принимать любой стек, и её не важно что в программе на стек останутся ссылки. Для этого можно сделать обязательный метод в интерфейсе содержит(стек)

    если цель.содержит(_стек)
        _стек = пусто
    иначе
        ошибка("предмет не перемещен")
}
слот.очистить(цель: МестоПодСтекИнтерфейс) {
    разместить(цель)    //А еще лучше предметами управлять отдельно от сумок вообще.
}

//****************************************************************
    Контейнеры и интерфейсы.
//****************************************************************
СумкаКонтейнер {
    get интерфейсСумки
    get интерфейсСбораАтрибутов
    get интерфейсСлотов если есть

    СумкаКонтейнер()
        _сумка = Сумка()    //универсальная сумка без слотов
        _сборАтрибутов = СборАтрибутов()
        //_сборАтрибутов = СборАтрибутов()
}

интерфейсСумки.добавитьПредмет(дерево, 123123) {
    _предметы
}
интерфейсСбораАтрибутов.сила
интерфейсСбораАтрибутов.ловкость

СуммаАтрибутовТолькоНаЧтениеИнтерфейс //Отдельный интерфейс на чтение? Как вариант: собираться они могут по разному, но на чтение - 1 общий интерфейс.
    значение(атрибут): число
    или
    get сила: число
    get ловкость: число
    ...

СуммаАтрибутовИнтерфейс
    добавитьПредмет(предмет)
    удалитьПредмет(предмет)
    и/или
    увеличитьАтрибут(ид, значение)  //вместе с предметами или без предметов - значения берутся из предметов и класс полностью независим от предметов. Тогда предметы могут быть изменены в любой момент без больших правок остального кода. Для этого тогда нужно один принцип взаимодействия с атрибутами.
    уменьшитьАтрибут(ид, значение)

//****************************************************************
    Генерация атриутов для героев и врагов.
//****************************************************************

//****************************************************************
    Враги и лут
    Точно ясно:
        Нужные зависимости передаются при атаке, а не при создании врага.
//****************************************************************

герой = Герой(воин, 10)
враг = Враг(кабан, 10,
    [10, 20],                       //золото
    120,                            //опыт
    [                               //лут
        [дерево, 1-3, 30%],
        [мясоКабана, 1-2, 50%],
        [шкураКабана, 1-2, 20%],
    ],
)

//это враги. Решено что атака будет происходить через интерфейс атаки и персонажи тут ни при чем.
атакаГероя: АтакаКонтероллерИнтерфейс = герой.атака
атакаВрага: АтакаКонтероллерИнтерфейс = враг.атака

атакаГероя.атака(атакаВрага)
атакаВрага.атака(атакаГероя)    //если может
//повторить n раз
атакаВрага.атака(атакаГероя)    //враг умирает
/*
    В вове, упрощено:
        Все атакующие получают опыт.
        На месте врага остаётся труп. В трупе генерируется лут из списка и золото из диапазона.

    т.е. враг знает кто его атаковал. Значит нужно както передать интерфейс золота, опыта, сумки.
*/

опыт: опытИнтерфейс = Опыт()
кошелек: кошелекИнтерфейс = Кошелек()
сумка: сумкаИнтерфейс = Сумка()         //Сейчас это обычная сумка на локацию. Может быть любая сумка: на героя, скрытая, сразу игрока. В том числе объединение сумок с тем же интерфейсом, почта и тд.

атакаГероя.атака(атакаВрага)            //Если интерфейс одинаковый, то как передать врагу опыт? атака(атака: АтакаИнтерфейс, опции?: {опыт, кошелек, сумка})
атакаВрага.атака(атакаГероя)

атакаГероя.атака(атакаВрага, опции: {опыт, кошелек, сумка})
атакаВрага.атака(атакаГероя, опции: {опыт, кошелек, сумка})     //но в этом нет смысла. Событие/колбек послеСмерти?

//допустим через замыкание
послеСмертиКоллбек = (генераторОпыта, генераторЗолота, генераторЛута) => {
    опыт += генераторОпыта.генерация()          //вернуть: число
    кошелек += генераторЗолота.генерация()      //вернуть: число
    сумка.добавить(генераторЛута.генерация())   //вернуть: {item: Item, count: unsigned} - и далее сумка или объединение сумок само разберется что делать.

    //или через "ооп"?
    генераторОпыта.генерация(опыт)
    генераторЗолота.генерация(кошелек)
    генераторЛута.генерация(сумка)
}

атакаГероя.атака(атакаВрага, послеСмертиКоллбек)    //функция всегда одна и храниться в атакаГероя переданного через конструктор
атакаВрага.атака(атакаГероя)    //Без метода.
/*
    Тогда получается нужно идти дальше до damage(damage: unsigned) и туда передавать этото коллбек... damage(damage: unsigned, коллбекПослеСмерти). И в kill(коллбекПослеСмерти)
    Всё равно в метод в котором может произойти смерть можно передавать коллбек. И у героя тоже будет такой же интерфейс?
*/

//****************************************************************
    Объекты и коллекции.
//****************************************************************
сумка = Сумка(20)
сумка = Сумка(20)
сумка = Сумка(20)
//...
сумка = Сумка(20)

герой = Герой(...)
герой = Герой(...)
герой = Герой(...)
//..
герой = Герой(...)

коллекция = Коллекция([
    герой,
    герой,
    герой,
    герой,
])
сумки
враги <--- ... если будет свободный доступ, то вот этот объект точно не должен доступен вне места использования. Враги существуют пока существует локация и не дольше.

герои.получитьГероя()
локация.добавитьГероя(герой)

//****************************************************************
    Конфиг атрибутов.
//****************************************************************
настройкиДляПриста = {
    инт: [9, 12],
    здоровье: [80, 120],
}
стандартныеНастройки = СтандартныеНастройкиСтроитель(данные)
//Все атрибуты указаны по умолчанию
стандартныеНастройки.настроить(настройкиДляПриста)
стандартныеНастройки.настроить(настройкиДляВоина)
...
настроить(настройки)
    перебор всех значений
    _инт = настройки.инт || _инт ???

настройки.настроить(строитель)
    строитель.установитьИнт(_инт)
    строитель.установитьЗдоровье(_здоровье)

//****************************************************************
    Сражение между группами.
//****************************************************************

группаГероев = ГруппаГероев(5)
группаВрагов = ГруппаВрагов(5)

группаГероев.добавить(герой1)
группаГероев.добавить(герой2)
группаГероев.добавить(герой3)
группаГероев.добавить(герой4)
группаГероев.добавить(герой5)

группаВрагов.добавить(враг1)
группаВрагов.добавить(враг2)
группаВрагов.добавить(враг3)

группаГероев.атакует(группаВрагов)

ИнтерфейсСражения
    удар(урон): boolean?

ГруппаДляСраженияПерсонажей
//ГруппаДляСраженияПерсонажей реализовать ИнтерфейсСражения
    //_персонажи: []  //У персонажей должны быть нужный интерфейс для сражения.
    _интерфейсСражения: []

    бой(целеваяГруппа: ГруппаДляСраженияПерсонажей)
        for интерфейсСражения в _интерфейсСражения
            целеваяГруппа.атака(интерфейсСражения)  //группа сама распределяет урон

    атака(интерфейсСраженияАтакующего)
        если _группаПустая
            возврат

        атака = интерфейсСраженияАтакующего.атака
        //Распределение между всеми участниками поровну.
        for интерфейсСражения в _интерфейсСражения
            интерфейсСражения.урон|удар(атака / _интерфейсСражения.длина)


герой.атака(интерфейсПолученияУрона)
если нужно атаковать группой:
герой1.атака(интерфейсПолученияУрона)
герой2.атака(интерфейсПолученияУрона)
...
//При этом сохраняется вся логика атаки каждого героя, логи.
группировкаУрона: интерфейсПолученияУрона   //декоратор или заместитель
    группировкаУрона(контроллерУрона: интерфейсПолученияУрона)
        _контроллерУрона = контроллерУрона
    получитьУрон(урон: число)
        _урон += урон
    завершить   //Должен гдето вызываться.
        _контроллерУрона.получитьУрон(_урон)

//****************************************************************
    Временная система состояний.
//****************************************************************

герой = Герой()

локация.добавитьГероя(герой)                                //можно: ..., нельзя: если находиться в другой активности, если мертвый - именно в таком порядке
локация.удалитьГероя(герой)                                 //можно: ..., нельзя:
подземелье.добавитьГероя(герой)                             //можно: ..., нельзя: если находиться в другой активности, если мертвый
герой.убить()                                               //можно: ..., нельзя: если мертвый
герой.воскресить()                                          //можно: ..., нельзя: если не мертвый
герой.экипировать(шлем)                                     //можно: ..., нельзя: если мертвый
герой.снятьЭкипировку(шлем)                                 //можно: ..., нельзя: если мертвый
герой.атаковать(враг)                                       //можно: ..., нельзя: если мертвый
герой.получитьУрон(враг)                                    //можно: ..., нельзя: если мертвый
герой.увеличитьАтрибут(сила, 42)                            //можно: ..., нельзя: если мертвый
герой.увеличитьАтрибут(максимальноеКолВоЗдоровья, 42)       //можно: ..., нельзя: если мертвый
герой.добавитьОпыта(42)                                     //можно: ..., нельзя: если мертвый
герой.распределитьОчкиОпыта(скилл, стоимость)               //можно: ..., нельзя: если мертвый
враг.найтиЦели(...)
/*
    1. Зависить должны "первые"/исполняемые компоненты. Иначе вся программа будет зависить только от одного компонента, который будет во всех конструкторах.
    2. Можно сделать 1 компонент или у каждого компонента методы вида can. Например может ли герой атаковать:
    состояние.можно(атака)  //нужно постоянно тянуть за собой компонент, который еще не известно как получить. Из любой точки программы можно проверить может ли герой атаковать.
    или
    герой.можноАтаковать(): boolean
*/

//****************************************************************
    Ошибки и исключения.
//****************************************************************

герой.убить
    //сейчас:
    ассерт(...)
    или
    если (естьСтатус(мертвый))
        сообщение(Герой мертвый)
        вернуть
    /* действия по убийству героя */

    //варианты:
    //Без явного условия и return в каждом методе.
    статус.проверка(живой, () => {
        //тут логика
    })
    //Это действие. Сейчас это просто метод внутри HealthPoints. Далее само действие может быть отдельным объектом с кучей другой логикой. Пока if/return в каждом методе пока не будет больше кода и контента.
    //... Действие внутри класса?

УбитьГероя
    УбитьГероя(здоровье)    //данные не доступны из вне... или
    выполнить()
        здоровье.ноль() //??? может isDead вынести отдельно в статус или контроллер? LifeController который не иметь отношение к здоровье. И сюдаже можно привязать генерацию лута у впага.

//****************************************************************
    ...
//****************************************************************

группаГероев
    _массив
    гет общиеПараметры  //Два интерфейса? Один на чтение, другой на add/remove - или add/remove не нужны вообще и будут только в классе.
    добавить(герой)
        _массив()
    удалить(герой)

//отдельный класс. Он может быть отдельно, или в составе класса с геттером - но класс отдельный. Его можно в любой момент поменять, передать чтото другое и тд.
общиеПараметры.живых
общиеПараметры.живых(герои)
общиеПараметры.мертвых
общиеПараметры.мертвых(герои)
общиеПараметры.общаяСила
общиеПараметры.общаяСила(герои)

Коллекция героев и группа героев - это разное.

//****************************************************************
    Герои и группы
//****************************************************************
- А что если добыча будет зависить не от действия, а от сумки? В жилу можо передать в любой момент сумку и всё. А сама сумка есть уже у собирателя?
Жила будет зависить не от собирателя, а от объекта сбора. А собиратель будет управлять объектом сбора, например сумкой.
Кстате с gather3(сумка) что можно использовать отдельно от героя - это логично. Жила теперь не зависит ни от чего. Кому надо - тот и проверяет свой объект может ли он собирать ресурсы. Далее может быть будет найден немного другой принцип. Вомзожно нужно передавать не сумку, а другой компонент, но не Собиратель.

сбор ресурсов из жил
атака врага или группу

герой.интерфейсСборкиРесурсов.собрать(жила)
или
жила.собрать(интерфейсСборкиРесурсов)   //интерфейсСборкиРесурсов входящий объект, жила исходящий по аналогии с атакой и уроном.
    значение = _генерацияРесурсов
    интерфейсСборкиРесурсов.добавить(значение)
    если _значение меньше нуля
        уничтожитьЖилу
//или
жила.собрать(сумка) //А из сумки уже забирает игрок.
    значение = _генерацияРесурсов
    остаток = сумка.добавит(_предмет, значение)
    значение -= остаток
    _значение -= значение
    //если остаток
    //    _значение += остаток    //Аналогия с вов: или во внутреннюю сумку и в следующий сбор будут возвращены предметы и сумки, а не новые.
жила._генерацияРесурсов
    вернуть случаноеЗначение([1, 3])

СборРесурсов: интерфейсСборкиРесурсов
    СборРесурсов(сумка, состояние)
    добавить(предмет, колво)
    //или
    собрать(жила)
        жила.собрать(_сумка)    //Сумка может быть любая, внутренняя техническая, локации, героя (если будет на каждого героя по сумке), сразу игрока и тд.

//****************************************************************
    сумка и сумки
//****************************************************************

ItemStorageInterface
    addItem(item, count)
    removeItem(item, count)
    removeItem(item, count)
    ...

ItemStorageCollection: ItemStorageInterface
    add()
    remove()

//****************************************************************
    id или сущности
//****************************************************************

//****************************************************************
    Старое. Всё в куче.
//****************************************************************

let attackPower = new AttackPower(
    10, //Значения фиксированные и не меняются.
    20,
);

attackPower.generate(); //Случайное значение из диапазона.

let attackPowerCharacterAttribute = new CharacterAttribute(42);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);

attackPower = new AttackPowerIncreaseDecorator(
    attackPower,
    attackPowerCharacterAttribute,  //И не нужно делать никаких действий над диапазоном. Он уже задан. А усиления просто сдвигают значения вправо.
);

range(): {left: number, right: number} {
    return {
        left: this._left + this._apCharacterAttribute.value(),
        right: this._right + this._apCharacterAttribute.value(),
    };
}

generateAttackPower(): number {
    //let range = this.range();
    //return _.random(this._left + this._apCharacterAttribute.value(), this._right + this._apCharacterAttribute.value());

    return this._attackPower.generateAttackPower() + this._apCharacterAttribute.value();
}

attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
//...

damage.attack(target) {
    let damage = _.range(this.left, this._right);

    target.attack(damage);
}

hero1.damage.attack(hero2.attackController);
//или
let damage = damage.generateAttack();
hero1.damageController.attack(damage);

//////////////////////////////////////////

/*
    Герой не может атаковать и совершать другие действия (двигаться) если мертвый.
    Герой не может атаковать и совершать другие действия (двигаться) если на нем какие-либо эффекты: стан.

    Цель не может получить урон если мертва.
    Цель не может получить урон на ней какие-либо эффекты: неуязвимость.

    Пока у героя только атака пусть это будет через дополнительный класс с методом assertCanAction() например.

    Кстате это разные действия. Получить урон - это просто операция с числами, атака - физическая.
    Герой не может просто так сменить состояние. Его нужно именно воскресить.
*/
hero.attack(target);

/////

//actionController.action('атака', hero);
hero.attack(target);
attack(target) {
    //this._actionController.assertAction('attack');
}

контроллер.действие(действие, () => {
    hero.attack(target);    //хм...
})

actionController = new ActionController();
hero //это контейнер. actionController внутри. Сам ни от чего не зависит. А нет - зависит. Тоже декоратор?

health = new Health();
health = new ActionController(health);  //и чё?
health = new Armor(health);
health = new MagicArmor(health);

//Надо сделать так, чтобы состояние нельзя было изменить из любой точки программы. Если объект ничего

health = new Health(actionController);
Health {
    Health(actionController) {
        this._actionController.assign(() => {
            return this._isDead;
        });
    }

    kill() {
        this._actionController.setState(Dead);
    }

    resurrect() {
        this._actionController.setState(Life);
    }
}

stun() {
    this._actionController.setState(Stun);
}

hero.block();
hero.unblock();
hero.assertAction('attack');

hero.addState('dead');  //Все остальные эффекты удаляются.
hero.addState('stun');  //Если есть эффект dead другие действия не возможны.

states = [];
if (state === dead) {
    states.clear();
    states.add(state);
}

// Вариант работы с сумками.

itemStorages.create(...);
itemStorages.create(...);
itemStorages.create(...);
itemStorages.add(...);  //Если сумка в банке.
create(factory) {
    let itemStorage = this._itemStorageCollection.create(factory.create);   //Проверка на максимальное число сумок.
    this._itemStorageGroup.add(itemStorage);    //Можно добавлять и удалять любые сумки.
    //Таким образом объект-контейнер содержит интерфейсы и сам обладает необходимым интерфейсом типа create/delete. И при этом наружу показывается не реализация, а интерфейс и поэтому this._itemStorageGroup возвращает интерфейс addItem(), а this._itemStorageCollection снаружи нет вообще. Т.е контейнер по сути есть............... декоратор или заместитель???
}
delete(itemStorage) {
    this._itemStorageCollection.delete(itemStorage);
    this._itemStorageGroup.delete(itemStorage);
}

itemStorages.delete(...);
itemStorages.delete(...);
itemStorages.delete(...);

//itemStorages.ItemStorageCollectionInterface;   //Для манипуляции с коллекцией. --- Не нужно, для этого есть сам контейнер реализующий интерфейс контейнера, и далее в проект передается не контейнер, а интерфейс. В том числе не нужно передавать будет по всему проекту GameObject и разбираться что это такое за объект.
itemStorages.AddItemInterface;                 //Для добавления предметов и только.

//----------------------------------------------
let itemStorageSlot = new ItemStorageSlot();
itemStorageSlot.createItem('wood', 12);
itemStorageSlot.replace(...);
itemStorageSlot.destroyItem();

//Предмет храниться внутри itemStack. ItemStack внутри слота сумки или слота экипировки. За логику добавление предмета в стек, удаления отвечает сам ItemStack. Значит к нему должен быть доступ из какого места программы. Дублировать интерфейс точно не надо.
//Вопрос: а как сортировать предметы в сумке? Слоты это же массив...

let slots = [
    new Slot(),
    new Slot(),
    //...
    new Slot(),
];

let itemStorage = new ItemStorage(slots);

//itemStorage.slots[3].separate(12);     //return new ItemStack(item, 12):
itemStorage.slots.get(3).separate(12);     //return new ItemStack(item, 12):    .get(3) выбросит исключение если слота нет.
//Можно управлять слотами по отдельности - они доступны снаружи.

//****************************************************************

//****************************************************************
окноГероя
    /*
        У интерфейса будет строго заданные элементы. Например просто добавить в массив или объект все характеристики не удобно. Будут в алфавитном порядке и не понятно что нужно.
    */
    обновитьСилу(42)
    обновитьЛовкость(42)
    обновитьИнтеллект(42)

    обновитьТекущийУровеньЗдоровья(42)
    обновитьМаксимальныйУровеньЗдоровья(42)

    обновитьСлотГоловы(шлем01)
    обновитьСлотГруди(нагрудник01)
    обновитьСлотШтанов(пусто)   //или очиститьСлотШтанов