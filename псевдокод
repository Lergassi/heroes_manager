бд = БазаДанных()   //Только предметы. А категории?

//прямые методы или с репозиториями, не суть
бд.найтиПредметПоКатегории(ресурсы)
бд.найтиПредметПоКатегории(одноручныеМечи)
бд.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

//Вариант с интерфейсом. И получается что не у бд куча методов, а у отдельного объекта, который есть у бд.
бд.поиск.найтиПредметПоКатегории(ресурсы)
бд.поиск.найтиПредметПоКатегории(одноручныеМечи)
бд.поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

создатьВрага(поиск: ИнтерфейсПоискаПредметов) {  //Таким образом когда будет создана нормальная бд не придется везде заменять объект ItemDatabase. А сам интерфейс будет браться из бд: бд.поиск - можно также? todo: Надо попробовать. Сделать так сумки и слоты. И героев.
    лут += поиск.найтиПредметПоКатегории(ресурсы)
    лут += поиск.найтиПредметПоКатегории(одноручныеМечи)
    лут += поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)
}

/*
    Факт: подобные данные не меняются не то что во время создания, а вообще в играх вроде. Только при разработке. Игру даже при разработке нужно перезагрузить.
    Получается что данные можно дублировать в сущности и бд и связать к данным объект?
*/
дерево = Предмет(дерево, ресурсы)
двуручныйМеч = Предмет(двуручныйМеч, одноручныеМечи, {двуручноеОружие: истина})
латныйШлем = Предмет(латныйШлем, шлемы, {материал: латы})

//Как это может быть
БазаДанных {
    БазаДанных() {
        _предметы = {}
        _поиск = Поиск()
    }

    добавить(id, предмет) {
            _предметы[id] = предмет
            _поиск.индекс(...) //А как если у предмета всё скрыто? Видимо не тут. Вроде как на каждый объект планируется фабрика (сущности, компоненты) - можно там всё делать.
        }

    //удалить(id | предмет) {
    //
    //}

    //метод
    найтиПредметПоКатегории(категория) {

    }
    //интерфейс
    поиск() {
        вернуть _поиск
    }
}

//Герои и интерфейс
Герой {

}

герой.слоты.голова.экипировать(шлем)
герой.слоты.плечи.экипировать(наплечники)
герой.слоты.праваяРука.экипировать(двуручныйМеч)
герой.слоты.леваяРука.экипировать(щит)  //Будет ошибка.

герой.атрибуты.сила
герой.атрибуты.силаАтаки

//Использование героев.
location.addHero(hero: ...) {}
простоГруппа.addHero(hero: ...) {}
подземельей.addHero(hero: ...) {}
рейд.addHero(hero: ...) {}
//и тд...
/*
    Допустим всем внутри нужны разные данные в кол-ве 2-3 интерфейсов.
    LevelInterface
    HeroClassInterface  //Максимум 1 танк на пати.
    КакойТоИнтерфейс
*/
//сейчас:
локация.добавитьГероя(герой: GameObject) {
    герой.получитьКомпонент(уровень)    //То что внутри нужен интерфейс уровня никто из разработчиков не знает. При условии что GameObject может содержать (или нет) всё что угодно.
}

//локация.добавитьГероя(герой: ...) {
локация.добавитьГероя(уровень: Уровень) {
    если уровень.значение < 42
        ошибка: Герой слишком маленький для данной локации.

    //герои.добавить(герой)   //А героя нету.
}

//И это должен быть именной герой. А в чем проблема сделать класс Герой и выкинуть GameObject? Внутри героя как в react соберу нужного героя.
локация.добавитьГероя(герой: УровеньИнтерфейс) {

}

Уровень {
    значение
    опыт
    добавитьОпыт(значение)
}

УровеньУГерояИнтерфейс {
    уровень: Уровень
}

//герой реализовать УровеньИнтерфейс {
//герой {
герой реализовать УровеньУГерояИнтерфейс, СлотыУГероя, КлассУГероя ... и тд - очень много интерфейсов которые, можно получить через геттер {
    уровень: Уровень
    слоты
    атака
    здоровье
    магия
    ...
}

ГеройКакReact {
    уровень
    сила
    ловкость
    интеллект
    очкиЗдоровья    //Какой смысл от подобного компонента на чтение? Нанести урон - отдельный компонент.
    очкиМагии

    ГеройКакReact(
        уровеньЧисло,
        сла,
        лов,
        инт,
    ) {
        уровень = Уровень(уровеньЧисло)
        сила = сла
        лов = лов
        //Полоучается очень большой конструктор. В фабрике и передавать внутрь? Все компоненты будут доступны из вне там где нужно.
    }
}

//*****************************************************************************************
    Один большой объект или много небольших + private/public
    private/public
    Пока итог такой:
        В сущностях все данные открыты через геттеры.
        По возможности использовать как со слотами - создавать на их основе объекты. Так удобно - можно заменить любую логику и не зависить от большого объекта.
        Там где можно использовать методы, а не данные.
            Например создать генератор золота можно через метод фабрику в одну строку вместо получения массива и передачи его генератору.
            Или данные у рецепта: не геттер а метод примерно такой создатьПредмет(списокСтеков | сумка) - и рецепт проверит можно ли создать рецепт и вернет нужно кол-во стеков или сразу поместит их в сумку.
//****************************************************************************************


Класс {
    private:
        /*
            И... какой смысл от этого если всё закрыто? Данные нужны в случайном месте.
            А зачем вообще нужен HeroClass? Как его использовать кроме данных?
            Допустим есть роль. Самое очевидное использование: если танк то {} иначе {}. Поведение героя будет зависить не от роли, а той логики которая будет передана ему.
                воин = Воин(
                    сила: 20,
                    защита: 30%,
                    стратегияНабораАгресии,
                )
            стратегияНабораАгресии у танка одна, у дд другая, у саппорта еще другая. А также в каждый класс можно передать уникальную стратегию.
            EquipSlot уже практически не используется в методах, а только при создании настоящего слота.
        */
        название
        главныеАтрибуты
        материалыБрони
        доступноеОружие
        роль
        опции = {
            доступныЩиты: 1
        }
        //И где в случайном месте правила для правой и левой рук.
    public:
        ...
}

воини = Класс(воин, [сила], [латы], [одноручноеОружие], танк)
маг = Класс(маг, [инт], [ткань], [посохи, ванды], дд)
...

//---------------------------

let attackPower = new AttackPower(
    10, //Значения фиксированные и не меняются.
    20,
);

attackPower.generate(); //Случайное значение из диапазона.

let attackPowerCharacterAttribute = new CharacterAttribute(42);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);

attackPower = new AttackPowerIncreaseDecorator(
    attackPower,
    attackPowerCharacterAttribute,  //И не нужно делать никаких действий над диапазоном. Он уже задан. А усиления просто сдвигают значения вправо.
);

range(): {left: number, right: number} {
    return {
        left: this._left + this._apCharacterAttribute.value(),
        right: this._right + this._apCharacterAttribute.value(),
    };
}

generateAttackPower(): number {
    //let range = this.range();
    //return _.random(this._left + this._apCharacterAttribute.value(), this._right + this._apCharacterAttribute.value());

    return this._attackPower.generateAttackPower() + this._apCharacterAttribute.value();
}

attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
//...

damage.attack(target) {
    let damage = _.range(this.left, this._right);

    target.attack(damage);
}

hero1.damage.attack(hero2.attackController);
//или
let damage = damage.generateAttack();
hero1.damageController.attack(damage);

//////////////////////////////////////////

/*
    Герой не может атаковать и совершать другие действия (двигаться) если мертвый.
    Герой не может атаковать и совершать другие действия (двигаться) если на нем какие-либо эффекты: стан.

    Цель не может получить урон если мертва.
    Цель не может получить урон на ней какие-либо эффекты: неуязвимость.

    Пока у героя только атака пусть это будет через дополнительный класс с методом assertCanAction() например.

    Кстате это разные действия. Получить урон - это просто операция с числами, атака - физическая.
    Герой не может просто так сменить состояние. Его нужно именно воскресить.
*/
hero.attack(target);

/////

//actionController.action('атака', hero);
hero.attack(target);
attack(target) {
    //this._actionController.assertAction('attack');
}

контроллер.действие(действие, () => {
    hero.attack(target);    //хм...
})

actionController = new ActionController();
hero //это контейнер. actionController внутри. Сам ни от чего не зависит. А нет - зависит. Тоже декоратор?

health = new Health();
health = new ActionController(health);  //и чё?
health = new Armor(health);
health = new MagicArmor(health);

//Надо сделать так, чтобы состояние нельзя было изменить из любой точки программы. Если объект ничего

health = new Health(actionController);
Health {
    Health(actionController) {
        this._actionController.assign(() => {
            return this._isDead;
        });
    }

    kill() {
        this._actionController.setState(Dead);
    }

    resurrect() {
        this._actionController.setState(Life);
    }
}

stun() {
    this._actionController.setState(Stun);
}

hero.block();
hero.unblock();
hero.assertAction('attack');

hero.addState('dead');  //Все остальные эффекты удаляются.
hero.addState('stun');  //Если есть эффект dead другие действия не возможны.

states = [];
if (state === dead) {
    states.clear();
    states.add(state);
}

// Вариант работы с сумками.

itemStorages.create(...);
itemStorages.create(...);
itemStorages.create(...);
itemStorages.add(...);  //Если сумка в банке.
create(factory) {
    let itemStorage = this._itemStorageCollection.create(factory.create);   //Проверка на максимальное число сумок.
    this._itemStorageGroup.add(itemStorage);    //Можно добавлять и удалять любые сумки.
    //Таким образом объект-контейнер содержит интерфейсы и сам обладает необходимым интерфейсом типа create/delete. И при этом наружу показывается не реализация, а интерфейс и поэтому this._itemStorageGroup возвращает интерфейс addItem(), а this._itemStorageCollection снаружи нет вообще. Т.е контейнер по сути есть............... декоратор или заместитель???
}
delete(itemStorage) {
    this._itemStorageCollection.delete(itemStorage);
    this._itemStorageGroup.delete(itemStorage);
}

itemStorages.delete(...);
itemStorages.delete(...);
itemStorages.delete(...);

//itemStorages.ItemStorageCollectionInterface;   //Для манипуляции с коллекцией. --- Не нужно, для этого есть сам контейнер реализующий интерфейс контейнера, и далее в проект передается не контейнер, а интерфейс. В том числе не нужно передавать будет по всему проекту GameObject и разбираться что это такое за объект.
itemStorages.AddItemInterface;                 //Для добавления предметов и только.

//----------------------------------------------
let itemStorageSlot = new ItemStorageSlot();
itemStorageSlot.createItem('wood', 12);
itemStorageSlot.replace(...);
itemStorageSlot.destroyItem();

//Предмет храниться внутри itemStack. ItemStack внутри слота сумки или слота экипировки. За логику добавление предмета в стек, удаления отвечает сам ItemStack. Значит к нему должен быть доступ из какого места программы. Дублировать интерфейс точно не надо.
//Вопрос: а как сортировать предметы в сумке? Слоты это же массив...

let slots = [
    new Slot(),
    new Slot(),
    //...
    new Slot(),
];

let itemStorage = new ItemStorage(slots);

//itemStorage.slots[3].separate(12);     //return new ItemStack(item, 12):
itemStorage.slots.get(3).separate(12);     //return new ItemStack(item, 12):    .get(3) выбросит исключение если слота нет.
//Можно управлять слотами по отдельности - они доступны снаружи.