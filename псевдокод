бд = БазаДанных()   //Только предметы. А категории?

//прямые методы или с репозиториями, не суть
бд.найтиПредметПоКатегории(ресурсы)
бд.найтиПредметПоКатегории(одноручныеМечи)
бд.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

//Вариант с интерфейсом. И получается что не у бд куча методов, а у отдельного объекта, который есть у бд.
бд.поиск.найтиПредметПоКатегории(ресурсы)
бд.поиск.найтиПредметПоКатегории(одноручныеМечи)
бд.поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)

создатьВрага(поиск: ИнтерфейсПоискаПредметов) {  //Таким образом когда будет создана нормальная бд не придется везде заменять объект ItemDatabase. А сам интерфейс будет браться из бд: бд.поиск - можно также? todo: Надо попробовать. Сделать так сумки и слоты. И героев.
    лут += поиск.найтиПредметПоКатегории(ресурсы)
    лут += поиск.найтиПредметПоКатегории(одноручныеМечи)
    лут += поиск.найтиПредметПоКатегории(оружие, включаяДочерниеКатегории)
}

/*
    Факт: подобные данные не меняются не то что во время создания, а вообще в играх вроде. Только при разработке. Игру даже при разработке нужно перезагрузить.
    Получается что данные можно дублировать в сущности и бд и связать к данным объект?
*/
дерево = Предмет(дерево, ресурсы)
двуручныйМеч = Предмет(двуручныйМеч, одноручныеМечи, {двуручноеОружие: истина})
латныйШлем = Предмет(латныйШлем, шлемы, {материал: латы})

//Как это может быть
БазаДанных {
    БазаДанных() {
        _предметы = {}
        _поиск = Поиск()
    }

    добавить(id, предмет) {
            _предметы[id] = предмет
            _поиск.индекс(...) //А как если у предмета всё скрыто? Видимо не тут. Вроде как на каждый объект планируется фабрика (сущности, компоненты) - можно там всё делать.
        }

    //удалить(id | предмет) {
    //
    //}

    //метод
    найтиПредметПоКатегории(категория) {

    }
    //интерфейс
    поиск() {
        вернуть _поиск
    }
}

//Герои и интерфейс
Герой {

}

герой.слоты.голова.экипировать(шлем)
герой.слоты.плечи.экипировать(наплечники)
герой.слоты.праваяРука.экипировать(двуручныйМеч)
герой.слоты.леваяРука.экипировать(щит)  //Будет ошибка.

герой.атрибуты.сила
герой.атрибуты.силаАтаки

//Использование героев.
location.addHero(hero: ...) {}
простоГруппа.addHero(hero: ...) {}
подземельей.addHero(hero: ...) {}
рейд.addHero(hero: ...) {}
//и тд...
/*
    Допустим всем внутри нужны разные данные в кол-ве 2-3 интерфейсов.
    LevelInterface
    HeroClassInterface  //Максимум 1 танк на пати.
    КакойТоИнтерфейс
*/
//сейчас:
локация.добавитьГероя(герой: GameObject) {
    герой.получитьКомпонент(уровень)    //То что внутри нужен интерфейс уровня никто из разработчиков не знает. При условии что GameObject может содержать (или нет) всё что угодно.
}

//локация.добавитьГероя(герой: ...) {
локация.добавитьГероя(уровень: Уровень) {
    если уровень.значение < 42
        ошибка: Герой слишком маленький для данной локации.

    //герои.добавить(герой)   //А героя нету.
}

//И это должен быть именной герой. А в чем проблема сделать класс Герой и выкинуть GameObject? Внутри героя как в react соберу нужного героя.
локация.добавитьГероя(герой: УровеньИнтерфейс) {

}

Уровень {
    значение
    опыт
    добавитьОпыт(значение)
}

УровеньУГерояИнтерфейс {
    уровень: Уровень
}

//герой реализовать УровеньИнтерфейс {
//герой {
герой реализовать УровеньУГерояИнтерфейс, СлотыУГероя, КлассУГероя ... и тд - очень много интерфейсов которые, можно получить через геттер {
    уровень: Уровень
    слоты
    атака
    здоровье
    магия
    ...
}

ГеройКакReact {
    уровень
    сила
    ловкость
    интеллект
    очкиЗдоровья    //Какой смысл от подобного компонента на чтение? Нанести урон - отдельный компонент.
    очкиМагии

    ГеройКакReact(
        уровеньЧисло,
        сла,
        лов,
        инт,
    ) {
        уровень = Уровень(уровеньЧисло)
        сила = сла
        лов = лов
        //Полоучается очень большой конструктор. В фабрике и передавать внутрь? Все компоненты будут доступны из вне там где нужно.
    }
}

//*****************************************************************************************
    Один большой объект или много небольших + private/public
    private/public
    Пока итог такой:
        В сущностях все данные открыты через геттеры.
        По возможности использовать как со слотами - создавать на их основе объекты. Так удобно - можно заменить любую логику и не зависить от большого объекта.
        Там где можно использовать методы, а не данные.
            Например создать генератор золота можно через метод фабрику в одну строку вместо получения массива и передачи его генератору.
            Или данные у рецепта: не геттер а метод примерно такой создатьПредмет(списокСтеков | сумка) - и рецепт проверит можно ли создать рецепт и вернет нужно кол-во стеков или сразу поместит их в сумку.
        Возможно сущности Item тоже не будет. Данные и логика будут передаваться в объект отдельно и никак не будут зависеть от Item.
//****************************************************************************************


Класс {
    private:
        /*
            И... какой смысл от этого если всё закрыто? Данные нужны в случайном месте.
            А зачем вообще нужен HeroClass? Как его использовать кроме данных?
            Допустим есть роль. Самое очевидное использование: если танк то {} иначе {}. Поведение героя будет зависить не от роли, а той логики которая будет передана ему.
                воин = Воин(
                    сила: 20,
                    защита: 30%,
                    стратегияНабораАгресии,
                )
            стратегияНабораАгресии у танка одна, у дд другая, у саппорта еще другая. А также в каждый класс можно передать уникальную стратегию.
            EquipSlot уже практически не используется в методах, а только при создании настоящего слота.
        */
        название
        главныеАтрибуты
        материалыБрони
        доступноеОружие
        роль
        опции = {
            доступныЩиты: 1
        }
        //И где в случайном месте правила для правой и левой рук.
    public:
        ...
}

воини = Класс(воин, [сила], [латы], [одноручноеОружие], танк)
маг = Класс(маг, [инт], [ткань], [посохи, ванды], дд)
...

//*****************************************************************************************
    Контейнеры с логикой интерфейсов.
//*****************************************************************************************

ItemStorageContainer {
    ItemStorageContainerInterface();        //Добавление, удаление предметов. А внутри оно храниться по своей логике. Никаких слотов.
    ItemStorageSlotInterface();             //Привязка к внутренней структуре.
}

itemStorage.ItemStorageContainerInterface.addItem(wood, 123);   //Просто в сумку с объединением.
itemStorage.ItemStorageContainerInterface.removeItem(wood, 123);
itemStorage.ItemStorageContainerInterface.hasItem(wood);

ItemStorageContainer(размер) {
    _контейнер = Контейнер(размер)      //Это без слотов. Просто контейнер.
    _слоты = Слот()[размер]             //Это сами слоты. Не имеют отношения к сумкам.
}

//дерево 2000, стек = 20 = 50 стеков, размер контейнера = 20. 1000 не добавяться.
добавитьПредмет(предмет, кол_во) {
    //вернуть _добавитьПредметыСОбъединение(предмет, кол_во)  //остаток
    //А как получить доступ к...
    //_контейнер.добавитьПредмет(предмет, кол_во) //Там внутри тоже есть стеки.
    стеки = _контейнер.добавитьПредмет(предмет, кол_во) //Там внутри тоже есть стеки.
    //!!! А что если слоты передать через зависимость. Для простого контейнера это просто массив. Для игрока это слоты сумки... хм... Что мне мешает управлять слотами отдельно? Я же могу очистить слот в обход сумки? слот.очистить()

    //_слоты.добавить
}
удалитьПредмет(предмет, кол_во) {
    _контейнер.удалитьПредмет(предмет, кол_во)
}

itemStorage.ItemStorageSlotInterface.slot(12).clear();
clear(index) {
    this.ItemStorageContainerInterface.remove(this._slots[index].item, this._slots[index].count);
    this._slots[index].clear();
}

HeroContainer {
    Слоты
    Предметы    //Отдельно от слотов.
    Атрибуты
}

//*****************************************************************************************
    Контейнеры с инъекцией слотов.
//*****************************************************************************************
/*
    Заметка про стеки. Стек может быть с maxSize для сумок или без ограничений например для лута. Например в луте может быть 5 MagicResource или 10 мечей в стеке - нет, плохая идея.
*/
/*
    Все сценарии работы с сумками и предметами в сумках.
        - Добавление/удаление предметов. С объединением стеков.
        - Разделение стека, объединение в стек.
        - Сортировка.
        - Перемещение из одного слота в другой.
*/

КонтейнерБезСлотов {
    _слоты: Стек[]
    КонтейнерБезСлотов(размер) {
        _слоты = Стек[размер]
    }
    добавитьПредмет(предмет, кол_во) {
        алгоритм: добавить предметы. Не полные стеки дополняются, создаются новые стеки. Если предметы останутся возврат остатка. Просто заполняется обычный массив. Вне класса ничего не доступно.

    }
    //Если просто массив, то удаление предмета будет так:
    удалитьПредмет(предмет, кол_во) {
        for индекс в _слоты
            если остаток <= 0
                break

            если _слоты[индекс] не пусто
                остаток = _слоты[индекс].удалить(предмет, кол_во) //стек сам разберется. Если там есть предмет удаление, иначе ничего не делать и возврат остаток = кол_во
                //И самое главное: как стек удалит себя если стек снизиться до нуля?
            //А если без проверки массива на существование стека и с слотом.
            _слоты[индекс].удалить(предмет, кол_во) //Та же логика без условий. И внутри если стек больше не нужен, то слот удалит его. При это логика тут вообще не затрониться и не сломается...
            /*
                Идея. Стек можно удалять или создавать. Во-первых зачем его создавать/удалять если можно просто указывать item/count в слоте? И добавлять предметы не стеку, а слоту.
                Во-вторых. Если стек будет. То стек предполагается создание и удаление. Сам себя стек не может удалить, аэто значит что нужна обертка для стек. Если это будет сумка:
                    _стеки[индекс].удалить(предмет, кол_во)
                    если _стеки[индекс].пустой()    //Тут получается что стек становится в не верном состоянии, что не должно допускаться.
                        _стеки[индекс] = пусто  //сам стек снаружи должен быть не доступен иначе вся логика сломается. С героями по другому - если герой снаружи чтото делает у него меняется статус.
                Если стек снизиться до нуля, а выше по коду не будет логики удаления стека из места - останется пустой стек. Без стеков?
                Получается чтобы управлять стеком нужен другой класс? СтекКонтроллер
            */
    }
}

КонтейнерСоСлотами {
    _слоты: СлотИнтерфейс[]
    КонтейнерСоСлотами(слоты: СлотИнтерфейс[]) {    //Только может не СлотИнтерфейс, а СтекИнтерфейс? Слоты нужны только для игрока.
        _слоты = слоты
    }
    добавитьПредмет(предмет, кол_во) {
        тот же алгоритм, только слоты теперь объект
        _слот[12].добавить(предмет, кол_во) //если внутри правильный объект - добавляется, иначе создается стек. возврат остаток
        for слот в _слоты
            если кол_во <= 0
                break

            кол_во -= слот.добавитьПредмет(предмет, кол_во) //И получается: сумка ничего не знает о стеках и как с ними работать - это работа за слотом. И если мне нужно очистить определенный слот для этого есть отдельный массив слотов. А что если слоты тоже выделить в отдельный класс? Если мне нужно очитить слот просто нужно ввести index вместо сумкаИД слотИД.
    }
}

//Если убрать стеки.
СлотСумки {
    СлотСумки() {
        _предмет = пусто
        _кол-во = 0
    }
    добавитьПредмет(предмет, кол-во) {
        если пусто
            _предмет = предмет
            _кол-во = кол-во <= предмет.размерСтека ? кол-во : предмет.размерСтека
            кол-во -= _кол-во
        иначе
            новыхПредметов = кол-во <= тут.недостаток() ? кол-во : тут.недостаток()
            _кол-во += новыхПредметов
            кол-во -= новыхПредметов

        возврат кол-во
    }
    удалитьПредмет(предмет, кол-во) {}
    естьлиПредмет(предмет, кол-во) {}
}

/*
    Если со стеком, то сначала нужно проверить создан ли он и потом его использовать.
    если стол.пустой
        слот.создатьСтек
    иначе
        слот.стек.добавитьПредмет(предмет, кол-во)
*/

СлотЭкипировки {
    экипировкать(предмет) {}
    экипировкать(предмет, кол-во) {}    //Если это слот для используемых предметов.
    экипировкать(стек) {}
}

СлотПредмета {
    _стек

    get стек???

    установить() {}
    создать() {}
    очистить() {}

    добавить() {}   //Это к стеку.
    удалить(кол_во) {}   //Это к стеку.
}

//декоратор
/*
    СтекКонтроллер, СтекВраппер реализовать СтекИнтерфейс {
        _стек
        СтекКонтроллер(стек) {
        }
        удалитьПредмет(предмет, кол_во) {
            остаток = _стек.удалитьПредмет(предмет, кол_во)
            если остаток и _стек.содержит(предмет, 1)
                _стек = пусто
                остаток--
            //или если можно снизить до нуля. Проще тогда до нуля снижать стек.
            если _стек.пустой
                _стек = пусто
        }
    }
*/

//ВОПРОС: Так ли нужен стек для перемещения и прочих манипуляций? Например есть 2 стека дерева - это просто дерево. Если без стеков - то как делать сортировку? Что перемещать? А что если к сумке сделать еще 1 сумку дубликать и при сортировки просто добавлять тупа по порядку предметы а потом менять сумки?
СтекКонтроллер: СтекИнтерфейс?
    _стек
    СтекКонтроллер
        _стек = пусто
    добавить(предмет, кол-во)   //кол-во может быть больше стека 1000000000
        остаток = 0
        если !_стек
            _стек = Стек(предмет)
            // или если очень надо чтобы стек не был с 0 предметов
            _стек = Стек(предмет, 1)
            --кол-во
        остаток = _стек.добавить(предмет, кол-во)
        вернуть остаток
    уничтожить()    //ссылки на стека нет можно безопасно удалить объект
        _стек = пусто
    очистить(цель)
    разделить(цель: СтекКонтроллер, предмет, кол-во)
        если !_стек
            вернуть пусто или ошибка

        новыеСтек = _стек.разделить(предмет, кол-во) //новый стек может быть разметор n - 1. За правильное указание нужных значений отвечает другая часть программы и интерфейс. Никаких ошибок тут не будет - физически нельзя указать размер нового стека равное размеру исходного стека. И создается именно стек а не слот - поэтому стеки нужны. Например при резерве ресурсов для крафта их можно помещать в стек без ограничения на максимальный размер (отдельный класс) и помещать в сумку без слотов.
        //если _стек.пустой
        //    _стек = пусто

        //вернуть новыйСтек
        цель.разместить(новыйСтек)

//Сортировка и перемещение со слотами
слот.поменять(слот)
поменять(слот) {    //С экипировкой работать не будет.
    т_стек = слот._стек
    слот_стек = _стек
    _стек = т_стек
}

МестоПодСтекИнтерфейс
    разместить(стек)
    содержит(стек)

//**** Как перенести стек, чтобы он не потерялся.
слот.переместить(цель: МестоПодСтекИнтерфейс) {
    цель.разместить(_стек)  //Можно сделать так, что за управление стеком отвечает исходное место. Цель может принимать любой стек, и её не важно что в программе на стек останутся ссылки. Для этого можно сделать обязательный метод в интерфейсе содержит(стек)

    если цель.содержит(_стек)
        _стек = пусто
    иначе
        ошибка("предмет не перемещен")
}
слот.очистить(цель: МестоПодСтекИнтерфейс) {
    разместить(цель)    //А еще лучше предметами управлять отдельно от сумок вообще.
}

//*****************************************************************************************
//*****************************************************************************************

let attackPower = new AttackPower(
    10, //Значения фиксированные и не меняются.
    20,
);

attackPower.generate(); //Случайное значение из диапазона.

let attackPowerCharacterAttribute = new CharacterAttribute(42);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);

attackPower = new AttackPowerIncreaseDecorator(
    attackPower,
    attackPowerCharacterAttribute,  //И не нужно делать никаких действий над диапазоном. Он уже задан. А усиления просто сдвигают значения вправо.
);

range(): {left: number, right: number} {
    return {
        left: this._left + this._apCharacterAttribute.value(),
        right: this._right + this._apCharacterAttribute.value(),
    };
}

generateAttackPower(): number {
    //let range = this.range();
    //return _.random(this._left + this._apCharacterAttribute.value(), this._right + this._apCharacterAttribute.value());

    return this._attackPower.generateAttackPower() + this._apCharacterAttribute.value();
}

attackPowerCharacterAttribute.increase(5);
attackPowerCharacterAttribute.increase(5);
//...

damage.attack(target) {
    let damage = _.range(this.left, this._right);

    target.attack(damage);
}

hero1.damage.attack(hero2.attackController);
//или
let damage = damage.generateAttack();
hero1.damageController.attack(damage);

//////////////////////////////////////////

/*
    Герой не может атаковать и совершать другие действия (двигаться) если мертвый.
    Герой не может атаковать и совершать другие действия (двигаться) если на нем какие-либо эффекты: стан.

    Цель не может получить урон если мертва.
    Цель не может получить урон на ней какие-либо эффекты: неуязвимость.

    Пока у героя только атака пусть это будет через дополнительный класс с методом assertCanAction() например.

    Кстате это разные действия. Получить урон - это просто операция с числами, атака - физическая.
    Герой не может просто так сменить состояние. Его нужно именно воскресить.
*/
hero.attack(target);

/////

//actionController.action('атака', hero);
hero.attack(target);
attack(target) {
    //this._actionController.assertAction('attack');
}

контроллер.действие(действие, () => {
    hero.attack(target);    //хм...
})

actionController = new ActionController();
hero //это контейнер. actionController внутри. Сам ни от чего не зависит. А нет - зависит. Тоже декоратор?

health = new Health();
health = new ActionController(health);  //и чё?
health = new Armor(health);
health = new MagicArmor(health);

//Надо сделать так, чтобы состояние нельзя было изменить из любой точки программы. Если объект ничего

health = new Health(actionController);
Health {
    Health(actionController) {
        this._actionController.assign(() => {
            return this._isDead;
        });
    }

    kill() {
        this._actionController.setState(Dead);
    }

    resurrect() {
        this._actionController.setState(Life);
    }
}

stun() {
    this._actionController.setState(Stun);
}

hero.block();
hero.unblock();
hero.assertAction('attack');

hero.addState('dead');  //Все остальные эффекты удаляются.
hero.addState('stun');  //Если есть эффект dead другие действия не возможны.

states = [];
if (state === dead) {
    states.clear();
    states.add(state);
}

// Вариант работы с сумками.

itemStorages.create(...);
itemStorages.create(...);
itemStorages.create(...);
itemStorages.add(...);  //Если сумка в банке.
create(factory) {
    let itemStorage = this._itemStorageCollection.create(factory.create);   //Проверка на максимальное число сумок.
    this._itemStorageGroup.add(itemStorage);    //Можно добавлять и удалять любые сумки.
    //Таким образом объект-контейнер содержит интерфейсы и сам обладает необходимым интерфейсом типа create/delete. И при этом наружу показывается не реализация, а интерфейс и поэтому this._itemStorageGroup возвращает интерфейс addItem(), а this._itemStorageCollection снаружи нет вообще. Т.е контейнер по сути есть............... декоратор или заместитель???
}
delete(itemStorage) {
    this._itemStorageCollection.delete(itemStorage);
    this._itemStorageGroup.delete(itemStorage);
}

itemStorages.delete(...);
itemStorages.delete(...);
itemStorages.delete(...);

//itemStorages.ItemStorageCollectionInterface;   //Для манипуляции с коллекцией. --- Не нужно, для этого есть сам контейнер реализующий интерфейс контейнера, и далее в проект передается не контейнер, а интерфейс. В том числе не нужно передавать будет по всему проекту GameObject и разбираться что это такое за объект.
itemStorages.AddItemInterface;                 //Для добавления предметов и только.

//----------------------------------------------
let itemStorageSlot = new ItemStorageSlot();
itemStorageSlot.createItem('wood', 12);
itemStorageSlot.replace(...);
itemStorageSlot.destroyItem();

//Предмет храниться внутри itemStack. ItemStack внутри слота сумки или слота экипировки. За логику добавление предмета в стек, удаления отвечает сам ItemStack. Значит к нему должен быть доступ из какого места программы. Дублировать интерфейс точно не надо.
//Вопрос: а как сортировать предметы в сумке? Слоты это же массив...

let slots = [
    new Slot(),
    new Slot(),
    //...
    new Slot(),
];

let itemStorage = new ItemStorage(slots);

//itemStorage.slots[3].separate(12);     //return new ItemStack(item, 12):
itemStorage.slots.get(3).separate(12);     //return new ItemStack(item, 12):    .get(3) выбросит исключение если слота нет.
//Можно управлять слотами по отдельности - они доступны снаружи.